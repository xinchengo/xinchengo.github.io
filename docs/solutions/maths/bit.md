# 位运算
## 概念
- 基本概念：原码，反码，补码。**正数的三者相等**，负数的反码是原码的取反，补码是反码加 1。
- 基本操作：`lowbit`, `getbit`, `revbit`, `setbit`。
- 二进制枚举子集：`for(int t=x;t;t=x&(t-1))`。

## P3048 \[USACO12FEB\]Cow IDs S
[题目链接](https://www.luogu.com.cn/problem/P3048)

大意：给出汉明权重为 k $(1 \leq k \leq 10)$ 的第 n $(1\leq n\leq 10^7)$ 个二进制数。

解法：这道题的标准解法是排列组合，但是我们还是可以模拟，并用位运算优化。求相同汉明权重的后继的代码[[hamming|见此]]。注意，要特判 $k = 1,2,3$ 的情况才能过题。

??? note "参考代码"
	```cpp linenums="1"
	--8<-- "code/P3048.cpp"
	```

## CF1508B Almost Sorted
[题目链接](https://www.luogu.com.cn/problem/CF1508B)

大意：一个长度为 n 的“几乎有序”的排列 a 满足 $\forall i\in [1,n-1]\cap \mathbf{N}^* , a_{i+1}\geq a_{i}-1$，我们称其为“几乎有序的”。给定长度 n，k，求出第 k 个长度为 n 的“几乎有序”排列。

解法：“几乎有序”的排列肯定可以分为若干段，其中在每一段中，后项等于前项加 1 或者前项减 1，易得，这些排列的个数共有 $2^{n-1}$ 个（首项是上升还是下降不影响结果）。若将上升和下降的状态看作二进制数中的 0 和 1，由于连续的 1 代表把后面的大数提前，不管在数值还是对应排列的字典序上都大于中间有 0 的排列，容易证明，二进制状态的大小直接反映排列的顺序。因此可以用二进制状态反推排列（写法类似双指针）。注意 n 较大时的特判。

??? note "参考代码"
	```cpp linenums="1"
	--8<-- "code/CF1508B.cpp"
	```

## CF1491D Zookeeper and The Infinite Zoo
[题目链接](https://www.luogu.com.cn/problem/CF1491D)

大意：若 $x\&y=y$，则 x 可以变成 x+y，问 u 是否可以经过若干次操作变为 v。$(1\leq u,v\leq 2^{30})$

解法：$x\&y=y$ 可以等同为 y 是 x 的子集。在操作后，1 只会向高位移动，且数量一定不变或者减少。从低到高枚举每位即可。

??? note "参考代码"
	```cpp linenums="1"
	--8<-- "code/CF1491D.cpp"
	```


