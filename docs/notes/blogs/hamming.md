# 生成汉明重量顺序的排列
## 汉明重量

汉明重量是一串符号中非零符号的个数。对于一个二进制数，它的汉明重量就等于它 $1$ 的个数（即 `popcount`）。

求一个数的汉明重量可以循环求解：我们将这个数不断地除以2，维护一个答案变量，在除的过程中根据最低位是否为 $1$ 更新答案。

代码如下：

```cpp
// 求 x 的汉明重量
int popcount(int x) {
    int cnt = 0;
    while (x) {
        cnt += x & 1;
        x >>= 1;
    }
    return cnt;
}
```

求一个数的汉明重量还可以使用 `lowbit` 操作：我们将这个数不断地减去它的 `lowbit`[^note4]，直到这个数变为 $0$。

代码如下：

```cpp
// 求 x 的汉明重量
int popcount(int x) {
    int cnt = 0;
    while (x) {
        cnt++;
        x -= x & -x;
    }
    return cnt;
}
```

### 构造汉明重量递增的排列

在 [状压 DP](https://oi-wiki.org/dp/state) 中，按照 popcount 递增的顺序枚举有时可以避免重复枚举状态。这是构造汉明重量递增的排列的一大作用。

下面我们来具体探究如何在 $O(n)$ 时间内构造汉明重量递增的排列。

我们知道，一个汉明重量为 $n$ 的最小的整数为 $2^n-1$。只要可以在常数时间构造出一个整数汉明重量相等的后继，我们就可以通过枚举汉明重量，从 $2^n-1$ 开始不断寻找下一个数的方式，在 $O(n)$ 时间内构造出 $0-n$ 的符合要求的排列。

而找出一个数 $x$ 汉明重量相等的后继有这样的思路，以 $(10110)_2$ 为例：

- 把 $(10110)_2$ 最右边的 $1$ 向左移动，如果不能移动，移动它左边的 $1$，以此类推，得到 $(11010)_2$。

- 把得到的 $(11010)_2$ 最后移动的 $1$ 原先的位置一直到最低位的所有 $1$ 都移到最右边。这里最后移动的 $1$ 原来在第三位，所以最后三位 $010$ 要变成 $001$，得到 $(11001)_2$。

这个过程可以用位运算优化：

```cpp
int t = x + (x & -x);
x = t | ((((t&-t)/(x&-x))>>1)-1);
```

- 第一个步骤中，我们把数 $x$ 加上它的 `lowbit`，在二进制表示下，就相当于把 $x$ 最右边的连续一段 $1$ 换成它左边的一个 $1$。如刚才提到的二进制数 $(10110)_2$，它在加上它的 `lowbit` 后是 $(11000)_2$。这其实得到了我们答案的前半部分。
- 我们接下来要把答案后面的 $1$ 补齐，$t$  的 `lowbit` 是 $x$ 最右边连续一段 $1$ 最左边的 $1$ 移动后的位置，而 $x$ 的 `lowbit` 则是 $x$ 最右边连续一段 $1$ 最左边的位置。还是以 $(10110)_2$ 为例，$t = (11000)_2$，$\operatorname{lowbit}(t) = (01000)_2$，$\operatorname{lowbit}(x)=(00010)_2$。
- 接下来的除法操作是这种位运算中最难理解的部分，但也是最关键的部分。我们设**原数**最右边连续一段 $1$ 最高位的 $1$ 在第 $r$  位上（位数从 $0$ 开始），最低位的 $1$ 在第 $l$ 位，$t$ 的 `lowbit` 等于 `1 << (r+1)` ，$x$ 的 `lowbit` 等于 `1 << l`， `((t&-t)>>1)/(x&-x)` 得到的，就是 `(1<<r)/(1<<l) = 1<<(r-l)` ，在二进制表示下就是 $1$ 后面跟上 $r-l$ 个零，零的个数正好等于连续 $1$ 的个数减去 $1$ 。举我们刚才的数为例，$\frac{\operatorname{lowbit(t)\div 2}}{\operatorname{lowbit(x)}} = \frac{(00100)_2}{(00010)_2} = (00010)_2$ 。把这个数减去 $1$ 得到的就是我们要补全的低位，或上原来的数就可以得到答案。

所以枚举 $0-n$ 按汉明重量递增的排列的完整代码为：

```cpp
for (int i = 0; (1<<i)-1 <= n; i++) {
    for (int x = (1<<i)-1, t; x <= n; t = x+(x&-x), x = x ? (t|((((t&-t)/(x&-x))>>1)-1)) : (n+1)) {
        // 写下需要完成的操作
    }
}
```

其中要注意 $0$ 的特判，因为 $0$ 没有相同汉明重量的后继。

[^note4]: 一个数二进制表示从低往高的第一个 $1$ 连同后面的零，如 $(1010)_2$ 的 `lowbit` 是 $(0010)_2$，详见 [树状数组](https://oi-wiki.org/ds/fenwick)。